fn calc_dg_mrna_rRNA(mrna_in: &str, rrna: &str, start_pos: usize, dangles: &DanglesSetting, constraints: &str) -> Result<bool, &str>{
    ///Calculates the dG_mRNA_rRNA from the mRNA and rRNA sequence.
    ///Considers all feasible 16S rRNA binding sites and includes the effects of non-optimal spacing."""

    // Collect all constants

    let begin = max(0, start_pos as isize - CUTOFF as isize) as usize;
    let mrna_len = min(mRNA_in.len(), start_pos + CUTOFF);
    let start_pos_in_subsequence = min(start_pos, CUTOFF);
    let startpos_to_end_len = mrna_len - start_pos_in_subsequence - begin;

    // 1. identify a list of rRNA-binding sites. Binding sites are hybridizations between the mRNA and rRNA and can include mismatches, bulges, etc. Intra-molecular folding is also allowed within the mRNA. The subopt program is used to generate a list of optimal & suboptimal binding sites.
    // Constraints: the entire rRNA-binding site must be upstream of the start codon

    let mRNA = &mRNA_in[begin..start_pos];
    if begin == start_pos {
        return Err("Warning: There is a leaderless start codon, which is being ignored.");
    }
    //include viennaRNA folding constraints due to binding of global regulator


    let constraints = if let Some(cons) = constraints {
        if cons.len() >= mRNA.len() {
            Some(cons[begin..start_pos].to_string()) // Slicing and converting to String
        } else {
            let mut extended_constraints = cons.to_string();
            extended_constraints.push_str(&".".repeat(mRNA.len() - cons.len())); // Fill the rest with dots
            Some(extended_constraints)
        }
    } else {
        None
    };
    
    let (subopt_energy, subopt_basepairing_x, subopt_basepairing_y) = subopt(
        &[mRNA, rRNA],
        constraints.as_deref(),
        ENERGY_CUTOFF,
        dangles,
        DEFAULT_TEMP,
    );

    if subopt_basepairing_x.is_empty() {return Ok((None, None, None));}


    // 2. Calculate dG_spacing for each 16S rRNA binding site

    // Calculate the aligned spacing for each binding site in the list
    let mut aligned_spacing = Vec::new();
    let loop_len = subopt_basepairing_x.len();
    for i in 0..loop_len {
        aligned_spacing.push(calc_aligned_spacing(
            rRNA, 
            mRNA, 
            start_pos_in_subsequence, 
            subopt_basepairing_x[i], 
            subopt_basepairing_y[i]
        ));
    }
    
    let mut dG_spacing_list = Vec::new();
    let mut dG_mRNA_rRNA = Vec::new();
    let mut dG_mRNA_rRNA_withspacing = Vec::new();
    

    // Calculate dG_spacing using aligned spacing value. Add it to dG_mRNA_rRNA.
    for i in 0..loop_len {
        dG_mRNA_rRNA.push(subopt_energy[i]);
        let val = calc_dG_spacing(aligned_spacing[i]);
        dG_spacing_list.push(val);
        dG_mRNA_rRNA_withspacing.push(val + subopt_energy[i]);
    }
    
    // Find 16S rRNA binding site that minimizes dG_spacing+dG_mRNA_rRNA.
    let (_, index) = find_min(&dG_mRNA_rRNA_withspacing);
    let dG_spacing_final = dG_spacing_list[index];
    let spacing_value = aligned_spacing[index];
    
    // Check: Is the dG spacing large compared to the energy gap? If so, this means the list of suboptimal 16S rRNA binding sites generated by subopt is too short.
    if dG_spacing_final > ENERGY_CUTOFF {
        if ostir_constants.verbose {
            println!("Warning: The spacing penalty is greater than the energy gap. dG (spacing) = {}", dG_spacing_final);
        }
    }
    // 4. Identify the 5' and 3' ends of the identified 16S rRNA binding site. Create a base pair list.



    let mut most_5p_mRNA = ostir_constants.infinity;
    let mut most_3p_mRNA = -ostir_constants.infinity;
    
    // Generate a list of rRNA-mRNA base paired nucleotides
    let mut bp_x_target = Vec::new();
    let mut bp_y_target = Vec::new();
    
    let bp_x = &subopt_basepairing_x[index];
    let bp_y = &subopt_basepairing_y[index];
    let loop_len = bp_x.len();
    
    for i in 0..loop_len {
        let nt_x = bp_x[i];
        let nt_y = bp_y[i];
        if nt_y > mRNA.len() { // nt is rRNA
            if let Some(index_match) = bp_y.iter().position(|&x| x == nt_y) {
                most_5p_mRNA = most_5p_mRNA.min(bp_x[index_match]);
                most_3p_mRNA = most_3p_mRNA.max(bp_x[index_match]);
                bp_x_target.push(nt_x);
                bp_y_target.push(nt_y);
            }
        }
    }
    
    //The rRNA-binding site is between the nucleotides at positions most_5p_mRNA and most_3p_mRNA
    //Now, fold the pre-sequence, rRNA-binding-sequence and post-sequence separately. 
    //Take their base pairings and combine them together. Calculate the total energy. 
    //For secondary structures, this splitting operation is allowed.
    //We postulate that not all of the post-sequence can form secondary structures. 
    //Once the 30S complex binds to the mRNA, it prevents the formation of secondary 
    //structures that are mutually exclusive with ribosome binding. We define self.footprint 
    //to be the length of the 30S complex footprint. Here, we assume that the entire mRNA 
    //sequence downstream of the 16S rRNA binding site can not form secondary structures.
    


    let begin = begin as usize;
    let most_5p_mRNA = most_5p_mRNA as usize;
    let most_3p_mRNA = most_3p_mRNA as usize;

    let mRNA_pre = &mrna_in[begin..begin + most_5p_mRNA - 1];
    let post_window_end = mrna_len + 1;
    let post_window_begin = std::cmp::min(start_pos + ostir_constants.footprint, post_window_end); // Footprint
    let post_window_end = mrna_len + 1;
    let mRNA_post = &mRNA_in[post_window_begin..post_window_end];

    let mut total_bp_x = Vec::new();
    let mut total_bp_y = Vec::new();

    let pre_constraints;
    let post_constraints;
    if let Some(constraints) = constraints {
        pre_constraints = Some(&constraints[begin..begin + most_5p_mRNA - 1]);
        post_constraints = Some(&constraints[post_window_begin..post_window_end]);
    } else {
        pre_constraints = None;
        post_constraints = None;
    }

    // Calculate pre-sequence folding
    if mRNA_pre.len() > 0 {
        let (mfe_basepairing_x, mfe_basepairing_y, _) = mfe(
            &[mRNA_pre],
            pre_constraints,
            DEFAULT_TEMP,
            dangles,
        );
        let bp_x_pre = mfe_basepairing_x;
        let bp_y_pre = mfe_basepairing_y;
    
        // Add pre-sequence base pairings to total base pairings
        total_bp_x.extend(bp_x_pre.iter().copied());
        total_bp_y.extend(bp_y_pre.iter().copied());
    } else {
        let bp_x_pre = Vec::new();
        let bp_y_pre = Vec::new();
    }
    
    // Add rRNA-binding site base pairings to total base pairings
    let rRNA_offset = std::cmp::min(startpos_to_end_len, cutoff);
    total_bp_x.extend(bp_x_target.iter().copied());
    for nt_y in &bp_y_target {
        total_bp_y.push(*nt_y + rRNA_offset);
    }
    
    // Calculate post-sequence folding
    if mRNA_post.len() > 0 {
        let (mfe_basepairing_x, mfe_basepairing_y, _) = mfe(
            &[mRNA_post],
            post_constraints,
            DEFAULT_TEMP,
            dangles,
        );
        let bp_x_post = mfe_basepairing_x;
        let bp_y_post = mfe_basepairing_y;
    
        let mut offset = post_window_begin - begin;
        for (&nt_x, &nt_y) in bp_x_post.iter().zip(bp_y_post.iter()) {
            total_bp_x.push(nt_x + offset);
            total_bp_y.push(nt_y + offset);
        }
    } else {
        let bp_x_post = Vec::new();
        let bp_y_post = Vec::new();
    }

    let mRNA = &mRNA_in[begin..mRNA_len];
    
    // @TODO: Change to dots
    let total_energy = eval_structure(&[mRNA, rRNA], &total_bp_x, &total_bp_y, DEFAULT_TEMP, dangles);
    
    let total_energy_withspacing = total_energy + dG_spacing_final;
    
}